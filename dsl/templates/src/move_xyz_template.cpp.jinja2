#include "arm_actions/arm_actions.hpp"

int main()
{
  // get current file path
  std::filesystem::path path = __FILE__;

  std::string log_path = path.parent_path().parent_path().parent_path().string() + "/logs/runs/";

  std::string data_path = path.parent_path().parent_path().parent_path().string() + "/logs/data/";

  // initialize logger
  std::shared_ptr<Logger> logger = std::make_shared<Logger>(true, false, log_path);

  // initialize plotter
  std::shared_ptr<GNUPlotter> plotter = std::make_shared<GNUPlotter>(data_path, true, false);

  // initialize utils
  std::shared_ptr<Utils> utils = std::make_shared<Utils>(logger);

  // initialize solver utils
  std::shared_ptr<SolverUtils> solver_utils = std::make_shared<SolverUtils>(logger);

  // get the robot urdf path
  std::string robot_urdf =
      (path.parent_path().parent_path() / "urdf" / "gen3_robotiq_2f_85.urdf").string();

  // set the base and tool links
  std::string base_link = "base_link";
  std::string tool_link = "bracelet_link";

  // define the robot chain
  KDL::Chain robot_chain;

  // define the initial joint angles
  std::vector initial_joint_angles = {0.0, 0.0, 0.0, -M_PI_2, 0.0, -M_PI_2, 0.0};

  // define the joint angles
  KDL::JntArray q;

  // initialize the robot
  int r = utils->initialize_robot(robot_urdf, robot_chain, base_link, tool_link,
                                  initial_joint_angles, q);
  if (r != 0)
  {
    logger->logError("Failed to initialize robot");
    return -1;
  }

  // number of joints
  int n_joints = robot_chain.getNrOfJoints();

  // number of segments
  int n_segments = robot_chain.getNrOfSegments();

  // compute the forward kinematics
  std::tuple<std::array<double, 3>, std::array<double, 3>> fk_result =
      solver_utils->computeFK(&robot_chain, q);

  // define unit constraint forces for EE
  KDL::Jacobian alpha_unit_forces;

  // beta - accel energy for EE
  KDL::JntArray beta_energy;

  // set the constraint weights
  std::array<double, 6> constraint_weights = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0};

  // set the solver parameters
  KDL::JntArray qd;              // input joint velocities
  KDL::JntArray qdd;             // output joint accelerations
  KDL::JntArray ff_tau;          // input feedforward torques
  KDL::JntArray constraint_tau;  // output constraint torques
  KDL::Wrenches f_ext;           // external forces at each segment

  // initialize vereshchagin solver
  KDL::ChainHdSolver_Vereshchagin vereshchagin_solver = solver_utils->initializeVereshchaginSolver(
      &robot_chain, constraint_weights, alpha_unit_forces, beta_energy, qd, qdd, ff_tau,
      constraint_tau, f_ext);
  
  {# coords -#}
  // coords
  {%- for coord in coords -%}
  {%- if "FrameCoordinate" in coords[coord]["type"] and coords[coord]["unit"] == "http://qudt.org/vocab/unit/M" %}
  std::string {{coords[coord]["f1"].split("#")[-1]}} = "{{coords[coord]["f1"].split("#")[-1]}}";
  std::array<double, 3> {{coords[coord]["f1"].split("#")[-1]}}_coord_position;
  {%- if "VectorXYZ" in coords[coord]["type"] +%}
  {{coords[coord]["f1"].split("#")[-1]}}_coord_position = { {{coords[coord]["x"]}}, {{coords[coord]["y"]}}, {{coords[coord]["z"]}} };
  {%+ else %}
  if (utils->checkLinkInChain(robot_chain, {{coords[coord]["f1"].split("#")[-1]}}))
  {
    int seg_n = utils->getLinkIdFromChain(robot_chain, {{coords[coord]["f1"].split("#")[-1]}});
    std::tuple<std::array<double, 3>, std::array<double, 3>> fk_result =
      solver_utils->computeFK(&robot_chain, q, seg_n);
    {{coords[coord]["f1"].split("#")[-1]}}_coord_position = std::get<0>(fk_result);
  }
  else
  {
    logger->logError("Not implemented");
    return -1;
  }
  {%+ endif -%}

  {%+ endif -%}
  {% endfor -%}
  
  {#+ monitors +#}
  // initialize the monitors
  {% for pre_cond in data["pre_conditions"] -%}
  {%- with constraint = constraints[pre_cond["constraint"]] -%}
  Monitor pre_monitor_{{loop.index}}(logger, "{{constraint["operator"]}}", 
                          {{constraint["thresh_val"]}}, 
                          "{{constraint["thresh_unit"]}}",
                          &{{coords[constraint["coord"]]["f1_coord"].split("#")[-1]}}_position);
  {% endwith %}
  {%- endfor -%}

  {# post conditions #}
  {% for post_cond in data["post_conditions"] -%}
  {%- with constraint = constraints[post_cond["constraint"]] -%}

  Monitor post_monitor_{{loop.index}}(logger, "{{constraint["operator"]}}",
                          {{constraint["thresh_val"]}}, 
                          "{{constraint["thresh_unit"]}}",
                          &{{coords[constraint["coord"]]["f1_coord"].split("#")[-1]}}_position);
  {% endwith %}
  {%- endfor -%}

  {#+ pid controllers #}
  // initialize the PID controllers
  {%- if data["mappings"]["controller"]["controller_type"] == "CascadedController" %}
  {% for controller in data["mappings"]["controller"]["data"] %}
  {%- with con_data = data["mappings"]["controller"]["data"][controller] -%}
  PIDController {{controller}}({{con_data["kp"]}}, {{con_data["ki"]}}, {{con_data["kd"]}});
  {%+ endwith -%}
  {%+ endfor +%}
  {% endif -%}

  // time step
  double dt = 0.001;

  // store positions and velocities
  std::vector<std::array<double, 3>> positions;
  std::vector<std::array<double, 3>> velocities;

  // control velocities and accelerations
  std::array<double, 6> control_velocities = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  std::array<double, 6> control_accelerations = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

  // counter
  int i = 0;
  int break_iteration_ = 500;

  // check if pre-conditions are met
  {%- for pre_cond in data["pre_conditions"] %}
  {%- with constraint = constraints[pre_cond["constraint"]] %}
  {% if "VectorXYZ" not in coords[coords[constraint["coord"]]["f2_coord"]]["type"] -%}
  if (!pre_monitor_{{loop.index}}.checkAny({{coords[constraint["coord"]]["f2_coord"].split("#")[-1]}}_position))
  {% else -%}
  if (!pre_monitor_{{loop.index}}.checkAny({{coords[constraint["coord"]]["f1_coord"].split("#")[-1]}}_position))
  {% endif -%}
  {
    logger->logError("Pre-condition {{loop.index}} not met");
    return -1;
  }
  {%- endwith %}
  {%- endfor %}

  // run the system at 1KHz
  while (true)
  {
    logger->logInfo("Iteration: %d", i);

    // compute the inverse dynamics
    int sr = vereshchagin_solver.CartToJnt(q, qd, qdd, alpha_unit_forces, beta_energy, f_ext,
                                           ff_tau, constraint_tau);
    if (sr < 0)
    {
      logger->logError("KDL: Vereshchagin solver ERROR: %d", sr);
      return -1;
    }

    // update the joint positions and velocities by integrating the accelerations
    for (int j = 0; j < n_joints; j++)
    {
      q(j) = q(j) + qd(j) * dt + 0.5 * qdd(j) * dt * dt;
      qd(j) = qd(j) + qdd(j) * dt;
    }

    // get the current link cartesian poses
    std::vector<KDL::Frame> frames(n_segments);
    vereshchagin_solver.getLinkCartesianPose(frames);

    // get the current link cartesian velocities
    std::vector<KDL::Twist> twists(n_segments);
    vereshchagin_solver.getLinkCartesianVelocity(twists);

    // print the joint positions, velocities, aceelerations and constraint torques
    logger->logInfo("Joint accelerations: %s", qdd);
    logger->logInfo("Joint torques: %s", constraint_tau);
    logger->logInfo("Joint velocities: %s", qd);
    logger->logInfo("Joint positions: %s", q);

    // update the beta energy
    {% if data["mappings"]["interface"] == "http://example.com/rob#acc_energy" %}
    {% if "lin_x" in data["mappings"]["controller-input-dimension"] and "lin_y" in data["mappings"]["controller-input-dimension"] and "lin_z" in data["mappings"]["controller-input-dimension"] %}
    {%- if data["mappings"]["controller"]["controller_type"] == "CascadedController" -%}
    {%- with pos_con_data = data["mappings"]["controller"]["data"]["pos_c"], vel_con_data = data["mappings"]["controller"]["data"]["vel_c"] -%}

    if ( i % {{(1 / pos_con_data["dt"])|int}} == 0 ){
      {%- with coord = constraints[pos_con_data["constraint"]]["coord"] -%}
      {%- if "VectorXYZ" in coords[coords[coord]["f1_coord"]]["type"] +%}
      auto target_position = {{coords[coords[coord]["f1_coord"]]["f1"].split("#")[-1]}}_coord_position;
      {% else %}
      auto target_position = {{coords[coords[coord]["f2_coord"]]["f1"].split("#")[-1]}}_coord_position;
      {%- endif %}
      {%- endwith %}
      // get the current tool cartesian pose
      int seg_n = utils->getLinkIdFromChain(robot_chain, {{coords[data["mappings"]["controller-input"]]["f1"].split("#")[-1]}});
      std::array<double, 3> current_position = {
        frames[seg_n].p.x(), frames[seg_n].p.y(), frames[seg_n].p.z()};
      positions.push_back(current_position); 
      auto con_vel = pos_c.computeControlSignal(current_position, target_position, {{pos_con_data["dt"]}});
      // update control velocities
      for (int j=0; j<con_vel.size(); j++)
      {
        control_velocities[j] = con_vel[j];
      }
    }

    if (i % {{(1 / vel_con_data["dt"])|int}} == 0)
    {
      int seg_n = utils->getLinkIdFromChain(robot_chain, {{coords[data["mappings"]["controller-input"]]["f1"].split("#")[-1]}});
      // get the current tool cartesian velocity
      std::array<double, 3> current_velocity = {twists[seg_n].vel.x(),
                                                twists[seg_n].vel.y(),
                                                twists[seg_n].vel.z()};
      velocities.push_back(current_velocity);
      auto con_acc = vel_c.computeControlSignal(current_velocity, 
          std::array<double, 3>{control_velocities[0], control_velocities[1],
                                                  control_velocities[2]},
          {{vel_con_data["dt"]}});
      // update control accelerations
      auto cod = std::vector<int>{ {{data["mappings"]["controller-output-dimension"]|join(",")}} };
      for (int j = 0; j < cod.size(); j++)
      {
        if (cod[j] == 1){
          control_accelerations[j] = con_acc[j];
        }
      }
    }

    solver_utils->updateBetaEnergy(beta_energy, control_accelerations);

    logger->logInfo("Control acc: %s", control_accelerations);

    {%- endwith %}
    {%- endif %}
    {%- endif %}
    {%- endif %}

    std::cout << std::endl;

    // check if post-conditions are met
    {%- for post_cond in data["post_conditions"] %}
    {%- with constraint = constraints[post_cond["constraint"]] %}
    {% if "VectorXYZ" not in coords[coords[constraint["coord"]]["f2_coord"]]["type"] -%}
    int seg_n = utils->getLinkIdFromChain(robot_chain, {{coords[coords[constraint["coord"]]["f2_coord"]]["f1"].split("#")[-1]}});
    {% else -%}
    int seg_n = utils->getLinkIdFromChain(robot_chain, {{coords[coords[constraint["coord"]]["f1_coord"]]["f1"].split("#")[-1]}});
    {% endif -%}
    std::array<double, 3> current_position = {
        frames[seg_n].p.x(), frames[seg_n].p.y(), frames[seg_n].p.z()};
    logger->logInfo("Current position: %s", current_position);
    if (post_monitor_{{loop.index}}.checkAll(current_position))
    {
      logger->logInfo("Post-condition {{loop.index}} met");
      break;
    }
    {%- endwith %}
    {%- endfor %}

    i++;
    
    if (i == break_iteration_)
      break;
  }

  plotter->plotXYZ(positions, target_link_coord_position);

  return 0;
}